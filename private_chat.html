<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿßŸÑÿÆÿßÿµÿ© - AirChat</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Link to global styles -->
    <link rel="stylesheet" href="style.css">
    <style>
        /* Specific styles for the private chat page */
        body {
            background-color: #f0f2f5; /* Light background */
            font-family: 'Inter', sans-serif;
            direction: rtl;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .private-chat-container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1; /* Allows container to expand */
        }

        .chat-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 1rem;
        }

        .chat-header img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #4f46e5;
        }

        .chat-header h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #4f46e5;
            flex-grow: 1;
            text-align: right;
        }

        #private-messages-display {
            flex-grow: 1; /* Allows messages to take available space */
            overflow-y: auto;
            background-color: #f9fafb;
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .private-message {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
        }

        .private-message.sent {
            background-color: #dcfce7; /* Light green for sent messages */
            align-self: flex-end; /* Align to right */
        }

        .private-message.received {
            background-color: #e0f2fe; /* Light blue for received messages */
            align-self: flex-start; /* Align to left */
        }

        .private-message strong {
            color: #4f46e5;
        }

        .chat-input-area {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .chat-input-area input {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            border: 1px solid #d1d5db;
        }

        .chat-input-area button {
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            font-weight: 600;
        }

        /* Dark mode adjustments */
        body.dark-mode .private-chat-container {
            background-color: #2a2a2a;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        body.dark-mode .chat-header {
            border-bottom-color: #444;
        }
        body.dark-mode .chat-header h2 {
            color: #a0a0ff;
        }
        body.dark-mode #private-messages-display {
            background-color: #333;
        }
        body.dark-mode .private-message.sent {
            background-color: #1e3a24; /* Darker green */
        }
        body.dark-mode .private-message.received {
            background-color: #1a2b3a; /* Darker blue */
        }
    </style>
</head>
<body class="dark:bg-gray-900">
    <div class="private-chat-container">
        <div class="chat-header">
            <button onclick="goBack()" class="button bg-gray-500 hover:bg-gray-600 px-4 py-2 text-sm">‚Ü©Ô∏è ÿ±ÿ¨Ÿàÿπ</button>
            <h2 id="recipient-username">ÿØÿ±ÿØÿ¥ÿ© ÿÆÿßÿµÿ©</h2>
            <img id="recipient-avatar" src="https://placehold.co/50x50/cccccc/333333?text=User" alt="Recipient Avatar">
        </div>

        <div id="private-messages-display">
            <!-- Private messages will be loaded here -->
        </div>

        <div class="chat-input-area">
            <input type="text" id="private-message-input" placeholder="ÿßŸÉÿ™ÿ® ÿ±ÿ≥ÿßŸÑÿ©..." />
            <button id="send-private-message-btn" class="button bg-blue-600 hover:bg-blue-700">ÿ•ÿ±ÿ≥ÿßŸÑ</button>
            <button id="send-private-gift-btn" class="button bg-pink-600 hover:bg-pink-700">üéÅ</button>
            <!-- Placeholder for image/voice message buttons -->
            <!-- <button class="button bg-green-600 hover:bg-green-700">üñºÔ∏è</button> -->
            <!-- <button class="button bg-red-600 hover:bg-red-700">üéôÔ∏è</button> -->
        </div>
    </div>

    <script type="module">
        import { socket, currentUser, showCustomAlert } from './js/main.js';
        import { showGiftAnimation } from './js/room_ui.js'; // Re-use gift animation

        const recipientId = new URLSearchParams(window.location.search).get('id');
        const recipientUsernameDisplay = document.getElementById('recipient-username');
        const recipientAvatarDisplay = document.getElementById('recipient-avatar');
        const privateMessagesDisplay = document.getElementById('private-messages-display');
        const privateMessageInput = document.getElementById('private-message-input');
        const sendPrivateMessageBtn = document.getElementById('send-private-message-btn');
        const sendPrivateGiftBtn = document.getElementById('send-private-gift-btn');

        let recipientData = null; // To store recipient's full data if available

        // Function to filter bad words (re-using from room_ui.js concept)
        function filterBadWords(text) {
            const badWords = ["ŸÉŸÑŸÖÿ©1", "ŸÉŸÑŸÖÿ©2", "badword", "fuck", "shit"]; // Example bad words
            let filteredText = text;
            for (const word of badWords) {
                const regex = new RegExp(word, 'gi');
                filteredText = filteredText.replace(regex, "****");
            }
            return filteredText;
        }

        // Function to add a private message to the display
        function addPrivateMessageToDisplay(message) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'private-message p-3 rounded-lg max-w-full break-words';

            if (message.senderId === currentUser.id) {
                msgDiv.classList.add('sent', 'bg-green-100', 'dark:bg-green-900', 'text-gray-800', 'dark:text-gray-100');
                msgDiv.innerHTML = `<strong>ÿ£ŸÜÿ™:</strong> ${filterBadWords(message.text)}`;
            } else {
                msgDiv.classList.add('received', 'bg-blue-100', 'dark:bg-blue-900', 'text-gray-800', 'dark:text-gray-100');
                msgDiv.innerHTML = `<strong>${message.senderUsername || 'ŸÖÿ¨ŸáŸàŸÑ'}:</strong> ${filterBadWords(message.text)}`;
            }
            privateMessagesDisplay.appendChild(msgDiv);
            privateMessagesDisplay.scrollTop = privateMessagesDisplay.scrollHeight; // Scroll to bottom
        }

        // Function to load private chat history (placeholder)
        async function loadPrivateChatHistory() {
            if (!currentUser || !recipientId) return;

            // In a real app, you'd fetch history from a backend API
            // Example: const response = await fetch(`/api/private-messages/${currentUser.id}/${recipientId}`);
            // For now, we'll just show a placeholder
            privateMessagesDisplay.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center">ÿ¨ÿßÿ±Ÿç ÿ™ÿ≠ŸÖŸäŸÑ ÿ≥ÿ¨ŸÑ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©...</p>';

            // Simulate fetching history
            setTimeout(() => {
                privateMessagesDisplay.innerHTML = ''; // Clear placeholder
                // Add dummy messages for demonstration
                addPrivateMessageToDisplay({
                    senderId: recipientId,
                    senderUsername: recipientUsernameDisplay.textContent,
                    text: 'ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ! ŸÉŸäŸÅ ÿ≠ÿßŸÑŸÉÿü',
                    timestamp: Date.now() - 60000
                });
                addPrivateMessageToDisplay({
                    senderId: currentUser.id,
                    senderUsername: currentUser.username,
                    text: 'ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ! ÿ£ŸÜÿß ÿ®ÿÆŸäÿ± ÿßŸÑÿ≠ŸÖÿØ ŸÑŸÑŸáÿå ŸÖÿßÿ∞ÿß ÿπŸÜŸÉÿü',
                    timestamp: Date.now() - 30000
                });
                privateMessagesDisplay.scrollTop = privateMessagesDisplay.scrollHeight;
            }, 1000);
        }

        // Event listener for sending a private message
        sendPrivateMessageBtn.addEventListener('click', () => {
            const messageText = privateMessageInput.value.trim();
            if (messageText && currentUser && recipientId) {
                socket.emit('sendPrivateMessage', {
                    recipientId: recipientId,
                    messageText: messageText
                });
                privateMessageInput.value = '';
                // Optimistically add message to display
                addPrivateMessageToDisplay({
                    senderId: currentUser.id,
                    senderUsername: currentUser.username,
                    text: messageText,
                    timestamp: Date.now()
                });
            } else if (!messageText) {
                showCustomAlert('ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÅÿßÿ±ÿ∫ÿ©.', 'warning');
            } else {
                showCustomAlert('Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ£Ÿà ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸÑŸÖ.', 'error');
            }
        });

        // Event listener for sending private gift
        sendPrivateGiftBtn.addEventListener('click', async () => {
            if (!currentUser || !recipientId) {
                showCustomAlert('Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ£Ÿà ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸÑŸÖ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸáÿØŸäÿ©.', 'error');
                return;
            }
            const confirmed = await showCustomConfirm(`ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ÿ±ÿ≥ÿßŸÑ ŸáÿØŸäÿ© ÿ•ŸÑŸâ ${recipientUsernameDisplay.textContent}ÿü`);
            if (confirmed) {
                socket.emit('sendGift', { toUserId: recipientId, giftType: 'Private Gift' });
                showCustomAlert(`ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ŸáÿØŸäÿ© ÿÆÿßÿµÿ© ÿ•ŸÑŸâ ${recipientUsernameDisplay.textContent}!`, 'success');
                showGiftAnimation();
                addPrivateMessageToDisplay({
                    senderId: currentUser.id,
                    senderUsername: currentUser.username,
                    text: `ÿ£ÿ±ÿ≥ŸÑ ŸáÿØŸäÿ© ÿÆÿßÿµÿ© ŸÑŸÄ ${recipientUsernameDisplay.textContent} üéÅ`,
                    timestamp: Date.now(),
                    type: 'gift_sent_notification' // Custom type for display
                });
            }
        });

        // Handle Enter key for sending messages
        privateMessageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendPrivateMessageBtn.click();
            }
        });

        // Listen for incoming private messages from Socket.IO
        document.addEventListener('newPrivateMessage', (event) => {
            const message = event.detail;
            // Only add if it's for the current chat window
            if ((message.senderId === recipientId && message.recipientId === currentUser.id) ||
                (message.senderId === currentUser.id && message.recipientId === recipientId)) {
                addPrivateMessageToDisplay(message);
            }
        });

        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            if (!currentUser) {
                showCustomAlert('Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©.', 'info');
                setTimeout(() => window.location.href = 'login.html', 1500);
                return;
            }

            if (recipientId) {
                // Fetch recipient's username and avatar (if not already known)
                // In a real app, you'd fetch this from your backend user profile API
                // For now, we'll use a placeholder or assume it's passed via localStorage/query
                const allUsers = JSON.parse(localStorage.getItem('allUsers') || '[]'); // Assuming a list of all users might be stored
                recipientData = allUsers.find(u => u.id === recipientId);

                if (recipientData) {
                    recipientUsernameDisplay.textContent = recipientData.username;
                    recipientAvatarDisplay.src = recipientData.avatar || 'https://placehold.co/50x50/cccccc/333333?text=User';
                } else {
                    // Fallback if recipient data not found locally
                    recipientUsernameDisplay.textContent = `ŸÖÿ≥ÿ™ÿÆÿØŸÖ ${recipientId}`;
                    recipientAvatarDisplay.src = 'https://placehold.co/50x50/cccccc/333333?text=User';
                    // Optionally, fetch from backend if not found locally
                    // fetch(`/api/users/${recipientId}/profile`).then(...).catch(...)
                }
                loadPrivateChatHistory();
            } else {
                showCustomAlert('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸÑŸÖ ŸÑŸÑÿØÿ±ÿØÿ¥ÿ© ÿßŸÑÿÆÿßÿµÿ©.', 'error');
                setTimeout(() => window.location.href = 'rooms.html', 2000); // Redirect if no recipient
            }
        });

        function goBack() {
            window.history.back();
        }
    </script>
</body>
</html>
